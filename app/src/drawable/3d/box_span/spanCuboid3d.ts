import * as THREE from "three"

import { SpanPoint3D } from "./spanPoint3d"
import { SpanLine3D } from "./spanLine3d"
import { SpanRect3D } from "./spanRect3d"
import { Vector3D } from "../../../math/vector3d"

/**
 * ThreeJS class for rendering 3D cuboid
 */
export class SpanCuboid3D {
  private readonly _p1: SpanPoint3D
  private readonly _p2: SpanPoint3D
  private readonly _p3: SpanPoint3D
  private readonly _p4: SpanPoint3D
  private _center: THREE.Vector3

  /**
   * Constructor
   *
   * @param p1
   * @param p2
   * @param p3
   * @param p4
   */
  constructor(
    p1: SpanPoint3D,
    p2: SpanPoint3D,
    p3: SpanPoint3D,
    p4: SpanPoint3D
  ) {
    this._p1 = p1
    this._p2 = p2
    this._p3 = p3
    this._p4 = p4
    this._center = new THREE.Vector3(0, 0, 0)
  }

  /**
   * Add to scene for rendering
   *
   * @param scene
   */
  public render(scene: THREE.Scene): void {
    // generate cuboid formed by four points and add to scene
    const bottomFace = new SpanRect3D(this._p1, this._p2, this._p3)
    const bottomFacePoints = bottomFace.points
    const newPoints = this.translateRect()
    const topFace = new SpanRect3D(newPoints[0], newPoints[1], newPoints[2])
    const topFacePoints = topFace.points
    this.calcCenter([...bottomFacePoints, ...topFacePoints])
    const newLines = this.connectingLines(bottomFacePoints, topFacePoints)

    bottomFace.render(scene)
    topFace.render(scene)
    for (const line of newLines) {
      line.render(scene)
    }
  }

  /** Return cuboid center */
  public get center(): THREE.Vector3 {
    return this._center
  }

  /** Return cuboid dimensions */
  public get dimensions(): THREE.Vector3 {
    if (
      this._p1 !== null &&
      this._p2 !== null &&
      this._p3 !== null &&
      this._p4 !== null
    ) {
      const v1 = new Vector3D(this._p1.x, this._p1.y, this._p1.z)
      const v2 = new Vector3D(this._p2.x, this._p2.y, this._p2.z)
      const v3 = new Vector3D(this._p3.x, this._p3.y, this._p3.z)
      const v4 = new Vector3D(this._p4.x, this._p4.y, this._p4.z)

      const width = v2.distanceTo(v3)
      const depth = v1.distanceTo(v2)
      const height = v3.distanceTo(v4)

      return new THREE.Vector3(width, depth, height)
    }

    return new THREE.Vector3(0, 0, 0)
  }

  /** Return cuboid rotation */
  public get rotation(): THREE.Quaternion {
    if (this._p1 !== null && this._p2 !== null) {
      const v1 = new Vector3D(this._p1.x, this._p1.y, this._p1.z)
      const v2 = new Vector3D(this._p2.x, this._p2.y, this._p2.z)

      const v12 = v2.clone().subtract(v1)
      const theta = Math.atan2(v12.y, v12.x)
      // TODO: figure out how to get the correct rotation
      // if (theta > Math.PI / 4) {
      //   theta -= Math.PI / 2
      // } else if (theta < -Math.PI / 4) {
      //   theta += Math.PI / 2
      // }

      const euler = new THREE.Euler()
      const angle = new THREE.Vector3(0, 0, theta)
      euler.setFromVector3(angle, "XYZ")
      const quaternion = new THREE.Quaternion()
      quaternion.setFromEuler(euler)

      return quaternion
    }
    return new THREE.Quaternion()
  }

  /** Translate plane generated by first three points */
  private translateRect(): SpanPoint3D[] {
    const v1 = new Vector3D(this._p1.x, this._p1.y, this._p1.z)
    const v2 = new Vector3D(this._p2.x, this._p2.y, this._p2.z)
    const v3 = new Vector3D(this._p3.x, this._p3.y, this._p3.z)
    const v4 = new Vector3D(this._p4.x, this._p4.y, this._p4.z)

    const v34 = v4.clone().subtract(v3)
    const newV1 = v1.clone().add(v34)
    const newV2 = v2.clone().add(v34)
    const newV3 = v3.clone().add(v34)

    const newP1 = new SpanPoint3D(newV1)
    const newP2 = new SpanPoint3D(newV2)
    const newP3 = new SpanPoint3D(newV3)

    return [newP1, newP2, newP3]
  }

  /**
   * Calculate cuboid center
   *
   * @param vertices
   */
  private calcCenter(vertices: SpanPoint3D[]): void {
    if (vertices.length > 0) {
      const v1 = new Vector3D(vertices[0].x, vertices[0].y, vertices[0].z)
      const v2 = new Vector3D(vertices[1].x, vertices[1].y, vertices[1].z)
      const v3 = new Vector3D(vertices[2].x, vertices[2].y, vertices[2].z)
      const v4 = new Vector3D(vertices[3].x, vertices[3].y, vertices[3].z)
      const v5 = new Vector3D(vertices[4].x, vertices[4].y, vertices[4].z)
      const v6 = new Vector3D(vertices[5].x, vertices[5].y, vertices[5].z)
      const v7 = new Vector3D(vertices[6].x, vertices[6].y, vertices[6].z)
      const v8 = new Vector3D(vertices[7].x, vertices[7].y, vertices[7].z)

      const vCenter = v1
        .clone()
        .add(v2)
        .add(v3)
        .add(v4)
        .add(v5)
        .add(v6)
        .add(v7)
        .add(v8)
      vCenter.divideScalar(vertices.length)

      this._center = new THREE.Vector3(vCenter.x, vCenter.y, vCenter.z)
    }
  }

  /**
   * Calculate lines connecting both faces
   *
   * @param points1
   * @param points2
   */
  private connectingLines(
    points1: SpanPoint3D[],
    points2: SpanPoint3D[]
  ): SpanLine3D[] {
    const l11 = new SpanLine3D(points1[0], points2[0])
    const l22 = new SpanLine3D(points1[1], points2[1])
    const l33 = new SpanLine3D(points1[2], points2[2])
    const l44 = new SpanLine3D(points1[3], points2[3])

    return [l11, l22, l33, l44]
  }
}
